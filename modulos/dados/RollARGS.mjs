export default class RollARGS extends Roll {
/**
	 * Main roll method for rolling. It checks if the roll is a
	 * d20, and if true, checks for special cases.
	 *
	 * The `data` object generally just needs an `actor` or and `item` as key:values.
	 *
	 * The `options` object configures the rolls, and chat messages. The following optional keys
	 * may be used:
	 * - fastForward {boolean}: Skips dialogs and just rolls normal rolls if set to true
	 * - rollMode {string}: If the self/gm/blind/public roll mode is to be predetermined
	 * - flavor {string}: Flavor text on the chat card (smaller text under actor name)
	 * - title {string}: Title of the chat card, set next to the icon
	 * - target {number}: If the roll has a target to meet or beat
	 * - dialogTemplate {handlebars}: Handlebars template to base Dialog on
	 * - dialogTitle {string}: The title of the rendered dialog
	 * - dialogOptions {object}: Options to be sent to the Dialog renderer
	 * - chatCardTemplate {handlebars}: Handlebars template to base Chatcard on
	 * - speaker {object}: Speaker as generated by `ChatMessage.getSpeaker()`
	 * - chatMessage {boolean}: Set to false if no chat message should be generated
	 *
	 * @param {Array<string>}		- Parts for the roll
	 * @param {object} data 		- Data that carries actor and/or item
	 * @param {jQuery} $form 		- Form from an evaluated dialog
	 * @param {number} adv			- Determine the direction of advantage (1)
	 * / disadvantage (-1)
	 * @param {object} options	- Options to modify behavior
	 * @returns {Promise<object>}
	 */
static async Roll(parts, data, $form, options={}) {
    // Augment data with form bonuses & merge into data

   	 const formBonuses = this._getBonusesFromForm($form);
     data = foundry.utils.mergeObject(data, formBonuses);

	 let BonoSituacional=0;
	 let BonoExtra=0;
	// Agrega partes de los modificadores del Form
	//const partsform = ["@BonoSituacional", "@BonoExtra"];
	if (data.rollType === "statsini") {
		BonoSituacional=0;
		BonoExtra=0;
	}
	else {
		BonoSituacional = data.itemBonus.split('"').join(''); // saca las comillas del valor del slider de bono situacional.
		BonoExtra = data.extraBonus.split('"').join('') || "0"; // saca las comillas del valor del slider de bono extra.
		
	}
	data.BonoSituacionalF = BonoSituacional;
	data.BonoExtraF=BonoExtra;

	data.BonoSituacional = data.BonoSituacionalF ;
	data.BonoExtra=data.BonoExtraF;

	
	if(data.item?.type === "armas" || data.rollType === "ataquemonstruo"){
	parts.unshift("@BonoSituacional");
	parts.unshift("@BonoExtra");
	}
	else if (data.rollType === "pericia") { 
		parts.push("@BonoSituacional");
		parts.push("@BonoExtra");
	
	}
	else if(data.item?.type === "hechizo"){
		
		parts.push("@BonoSituacional");
		parts.push("@BonoExtra");
	}
	else if(data.item?.type === "monturas"){
		if(data.flagInstinto ===1 || data.flagDestreza === 1){
		parts.push("@BonoSituacional");
		parts.push("@BonoExtra");
		}
		else{
		parts.unshift("@BonoSituacional");
		parts.unshift("@BonoExtra");	
		}
	}
	

	data.BonoSituacional = BonoSituacional;
	if (data.esRM === 1) {
		data.BonoExtra = (BonoExtra * -1);
	}
	
	if(data.item?.type === "armas" || data.rollType === "ataquemonstruo" || data.rollType === "ataquenpc") {
		//Bonos Correr y Saltar
		let enCarrera =0;
		let enSalto =0;
		if(data.bonoCorrer === true){
			enCarrera = 1;
		}
		if(data.bonoSaltar === true){
			enSalto = 1;
		}
		parts.unshift("@enSalto");
		data.enSalto = enSalto;
		parts.unshift("@enCarrera");
		data.enCarrera = enCarrera;
		
	}
	
	if (!options.rollMode) {
        // only override if it's actually been set on the form (some rolls
        // will have no form)		
        options.rollMode = $form
            ? this._getRollModeFromForm($form)
            : game.settings.get("core", "rollMode");		
    }


	
    // Roll the Dice
	
    data.rolls = {		
      main: await this._roll(parts, data), // por aca se va sin las opciones del rendered template item-card
    };
	
    if (data.rollType === "pericia") { //como llega acA?
		options.target = 1
        return this._renderRoll(data, options);

    }
	
	if (data.rollType === "statsini") {
        return this._renderRoll(data, options);
    }

    if (data.rollType === "hp") {
        return this._renderRoll(data, options);
    }

    // Roll damage for NPCs
    if (data.actor?.type === "npc" || data.actor?.type === "monstruo") {     
       
        return this._renderRoll(data, options);
    }
	
	if ( data.item?.type === "monturas" && (data.flagInstinto === 1  || data.flagDestreza === 1) ) {
	
		options.target=1;
		return this._renderRoll(data, options);
	}

    // Special cases for D20 rolls
    //if (this._isD20(parts)) {
        // Weapon? -> Roll Damage dice
        if(data.item?.type === "armas") {
		 return this._renderRoll(data, options);
       }

	   
        // TODO This should really be set in the ItemSD rollSpell method...
        // Spell? -> Set a target
        if (data.item?.type === "hechizo") {
           // options.target = data.item.system.tier + 10;
		   options.target = 1
            if (!options.flavor) {
                options.flavor = game.i18n.format(
                    "ARGS.infotexto.lanzandohechizo" ,
                    {
                        name: data.item.name,
                        //tier: data.item.system.tier,
                        //spellDC: options.target,
                    }
                );
            }
        }
   // } fin isD20

    // Check if it was a spell, and if it failed, lose it
	//options.target=true;	
    const result = await this._renderRoll(data,  options);
    // if (
    //     data.item?.isSpell()
    //     && result
    //     && !result?.rolls?.main?.success
    // ) data.item.update({"system.lost": true});
    return result;

	
}
/* -------------------------------------------- */
	/*  Roll Analysis                               */
	/* -------------------------------------------- */

	static _digestCritical(roll, options={}) {
		//if ( roll.terms[0].faces !== 20  && roll.terms[0].faces !== 10 ) return null;
		
		if (
			roll.terms.length > 0 &&
			roll.terms[roll.terms.length - 1].modifiers &&
			//roll.terms[roll.terms.length - 1].modifiers.includes("x>=")
			roll.data.item && (roll.data.item.type === "armas" || roll.data.item.type === "monturas" )
		  ) {
			const successThreshold = (options.critical?.successThreshold)
				? options.critical.successThreshold : roll.data.item.system.critumbral;	
			
			if ( roll.terms[roll.terms.length - 1].results[0].result === successThreshold ) return "success";			
			return null;
		  } // ATaques armas con dado explosivo.
		 if (
			roll.terms.length > 0 &&
			roll.terms[roll.terms.length - 1].modifiers &&
			//roll.terms[roll.terms.length - 1].modifiers.includes("x>=")
			roll.data.rollType === "ataquemonstruo"
		  ) {
			const successThreshold = (options.critical?.successThreshold)
				? options.critical.successThreshold : roll.data.actor.system.critumbral;	
			if ( roll.terms[roll.terms.length - 1].results[0].result === successThreshold ) return "success";			
			
			return null;
		  } // ATaques armas con dado explosivo.



		if ( roll.terms[0].faces === 10 ) {
		
		// Check if different threshold are given as options
		const failureThreshold = (options.critical?.failureThreshold)
			? options.critical.failureThreshold : 10;

		const successThreshold = (options.critical?.successThreshold)
			? options.critical.successThreshold : 1;
				
		if ( roll.terms[0].results[0].result === successThreshold ) return "success";
		else if ( roll.terms[0].results[0].result === failureThreshold ) return "failure";
		return null;
		}
		if( roll.terms[0].faces === 20 ) {
			// Check if different threshold are given as options
		
		const failureThreshold = (options.critical?.failureThreshold)
		? options.critical.failureThreshold : 20;

		const successThreshold = (options.critical?.successThreshold)
		? options.critical.successThreshold : 1;

		
		if ( roll.terms[0].results[0].result === successThreshold ) return "success";
		else if ( roll.terms[0].results[0].result === failureThreshold ) return "failure";
		return null;
		}
		else {
			return null;
		}
		
	}

	
		/**
	 * Removes the `@bonus` valeus from `parts` array that do not have
	 * corresponding `data.bonus` value, for a cleaner roll.
	 * @param {Array<string>} parts - Parts with bonuses to add to roll, starting with at
	 * @param {object} data 				- Data object containing `data.bonusX` values
	 * @returns {Array<string>}			- Parts with only defined bonuses in data object
	 */
		static _digestParts(parts, data) {
			const reducedParts = [];
			parts.forEach(part => {
				// If both the bonus is defined, and not 0, push to the results
				if (
					data[part.substring(1)] && parseInt(data[part.substring(1)], 10) !== 0
				) reducedParts.push(part);
			});
			return reducedParts;
		}


	/* -------------------------------------------- */
	/*  Dice Rolling                                */
	/* -------------------------------------------- */

	/**
	 * Rolls dice, with parts. Evaluates them, and returns the data.
	 * @param {Array<string>}	parts	- Dice and Bonuses associated with the roll `@bonus`
	 * @param {object} data					- Data for the roll, incl. values for bonuses, like
	 * `data.bonus`
	 * @returns {object} 						- Returns the evaluated `roll`, the rendered
	 * HTML `renderedHTML`, and `critical` info.
	 */
	static async _roll(parts, data={}) {		
		parts = this._digestParts(parts, data);
		
		let roll;
		let roll1;
		let roll2;
		let renderedHTML;
		let renderedHTML1;
		let renderedHTML2;
		let critical;
		let textoopcion;
		
		if (data.item?.type === "hechizo") {
		 roll = await new Roll("1d20cs<=("+parts.join(" + ")+")", data).evaluate({async: true});
		 renderedHTML = await roll.render();
		}
		if (data.item?.type === "monturas") {
			if(data.flagInstinto===1 || data.flagDestreza ===1 ){			
			roll = await new Roll("1d10cs<=("+parts.join(" + ")+")", data).evaluate({async: true});
			renderedHTML = await roll.render();
		   }
		   else {
			roll = await new Roll(parts.join(" + "), data).evaluate({async: true});
			renderedHTML = await roll.render();
		   }
		}
		
		if (data.actor?.type === "animales" && data.rollType === "pericia") {
			roll = await new Roll("1d10cs<=("+parts.join(" + ")+")", data).evaluate({async: true});
			
			renderedHTML = await roll.render();
		}
		if(data.rollType === "pericia" && data.actor.type === "monstruo" ){
			let BonoEx=new Roll(data.BonoExtraF??0,{});			
			BonoEx.evaluate();
			let sumatoria = Number(data.periciaFinal) + Number(BonoEx.result) + Number(data.BonoSituacionalF);
			if(data.actor.type ==="monstruo"){
			
			roll = await new Roll("1d6cs<=("+parts.join(" + ")+")", data).evaluate({async: true});	
			renderedHTML = await roll.render();
			
			}
		}

		if(data.rollType === "pericia" && data.esRM === 1 ){
			let BonoEx=new Roll(data.BonoExtraF??0,{});			
			BonoEx.evaluate();
			let sumatoria = Number(data.periciaFinal) + Number(BonoEx.result) + Number(data.BonoSituacionalF);
			
			roll = await new Roll("1d10cs<=("+parts.join(" + ")+")", data).evaluate({async: true});	
			renderedHTML = await roll.render();			
			
		}
		if (data.rollType === "statsini"){
			
				roll = await new Roll(parts.join(" + "), data).evaluate({async: true});
				renderedHTML = await roll.render();
				data.diezd4 = roll._total ;
				
				if(roll._total === roll.terms[0].rolls[0]._total) {
					data.arrayd4 = roll.terms[0].rolls[0].terms[0].results;
				}
				if(roll._total === roll.terms[0].rolls[1]._total) {
					data.arrayd4 = roll.terms[0].rolls[1].terms[0].results;
				}
				if(roll._total === roll.terms[0].rolls[2]._total) {
					data.arrayd4 = roll.terms[0].rolls[2].terms[0].results;
				}

				let countOfFours = 0;
				
			
				for (let i = 0; i < data.arrayd4.length; i++) {
				if (data.arrayd4[i].result === 4) {
					countOfFours++;
					
					
					if (countOfFours === 2 || countOfFours === 3 ) {					
						textoopcion = "ARGS.statroll.opcion1";
					} 
					if (countOfFours === 4) {					
						textoopcion = "ARGS.statroll.opcion2";
					} 
					if (countOfFours === 5) {					
						textoopcion = "ARGS.statroll.opcion3";
					} 
					if (countOfFours > 5) {					
						textoopcion = "ARGS.statroll.opcion4";
					} 
					 
				}
				}
				
		}
		if (data.rollType === "pericia" && (data.actor.type === "aventurero" || data.actor.type === "npc")) {    
			let BonoEx=new Roll(data.BonoExtraF??0,{});			
			BonoEx.evaluate();
			let sumatoria = Number(data.periciaFinal) + Number(BonoEx.result) + Number(data.BonoSituacionalF);
			if (sumatoria >= 10){				
				roll1 = await  new Roll("1d10cs<=("+parts.join(" + ")+")", data).evaluate({async: true});//new Roll("1d10",{}).evaluate({async: true});					
								
				if (roll1.terms[0].results[0].result === 10 ){
					// no tiene seteado el rolls?
					renderedHTML1 = await roll1.render();
					
					parts.push("@sacarprimerapifia");					
					data.sacarprimerapifia = -10;

					roll2 = await new Roll("1d10cs<=("+parts.join(" + ")+")", data).evaluate({async: true});///new Roll("1d10",{}).evaluate({async: true});	
					roll2._dice._total = roll2.total+10; //suma la pifia (10) del primer dado.
					if (roll2.terms[0].results[0].result === 1){
						critical=undefined; //para que no tome como critico el segundo dado de evaluacion.
					}

					if(roll2._dice._total ===20){
						data.rolls.main.critical="failure";
						critical="failure";
					}
					
					if(roll2._dice._total > sumatoria){ //falla pericia
						roll = roll2;
						renderedHTML = await roll2.render();						
					}
					else{
						roll = roll2;											
						renderedHTML = await roll2.render();						
					}
				
				}
				else {		
					roll = roll1;//await new Roll("1d10cs<=("+parts.join(" + ")+")", data).evaluate({async: true});
					renderedHTML = await roll1.render();
					roll1=undefined;					
				} //ya fue exitoso con la primer tirada
			}
			if (sumatoria < 10){			
			roll = await new Roll("1d10cs<=("+parts.join(" + ")+")", data).evaluate({async: true});
			renderedHTML = await roll.render();
			}
		}	
		else if (data.item?.type === "armas" || data.rollType === "ataquemonstruo") {
		roll = await new Roll(parts.join(" + "), data).evaluate({async: true});
		renderedHTML = await roll.render();
			if (data.item?.type === "armas") {
			data.BOBD = roll._total + data.actor.system.calculados.BD.final;
			}
			if (data.rollType === "ataquemonstruo") {
			data.BOBD = roll._total + data.actor.system.bonifdefensiva;
			}
		 }
		
	
		//const renderedHTMLSpell = await rollSpell.render();
		//renderedHTML = await roll.render();
		// if (roll1){
		// renderedHTML1 = await roll1.render();
		// }
		// if (roll2){
		// renderedHTML2 = await roll2.render();   
		// }	
		//const renderedHTML = await roll.render();
		// Also send the actors critical bonuses in case it has modified thresholds
		critical = this._digestCritical(roll, data.actor?.system?.bonuses);

		// formulas y cambios con criticos y aciertos.
		if ((critical === "success" || critical === "failure") && data.actor.type === "aventurero"){
			if(data.rollType === "pericia" && data.esRM !== 1) {
			let Avance1= data.actor.system.pericias[data.categoria][data.pericia].avance + 1;
			data.actor.update({[`system.pericias.${data.categoria}.${data.pericia}.avance`] : Avance1});
			}
			if(data.item?.type && data.item?.type === "armas"){
			let Avance1= data.actor.system.pericias.combate[data.item.system.atacaCon].avance + 1;
			data.actor.update({[`system.pericias.combate.${data.item.system.atacaCon}.avance`] : Avance1});
			}
			if(data.item?.type && data.item?.type === "hechizo"){
			let Avance1= data.actor.system.calculados.conjurar.avance + 1;
			data.actor.update({[`system.calculados.conjurar.avance`] : Avance1});			
			}
		}

		/// cambio a preparado.
		if (data.actor.type === "aventurero" && data.item?.type === "hechizo" && roll._total === 1){
			data.item.update({[`system.preparado`] : true});				
			}
	
		if (data.rollType === "pericia" && data.actor.type === "aventurero" ) {     //|| data.actor.type === "npc")
			return {
				roll1,
				roll,
				renderedHTML,
				renderedHTML1,
				critical,
			};	
		}	
		if (data.rollType === "statsini"){
		return {
			roll,
			renderedHTML,
			textoopcion,
			
			};	
			
		}	
		else{
		return {
				roll,
				renderedHTML,
				critical,
			};
		}

	}

	
	
	/* -------------------------------------------- */
	/*  Dialog & Form Digestion                     */
	/* -------------------------------------------- */

	/**
	 * Extract the roll mode from a form
	 * @param {jQuery} $form 	- Callback HTML from dialog
	 * @returns {string}			- Selected Rollmode
	 */
	static _getRollModeFromForm($form) {		
		return $form.find("[name=rollMode]").val();		
	}

	/**
	 * Parses a submitted dialog form for bonuses
	 * @param {jQuery} $form 	- Submitted dialog form
	 * @returns {object}			- Bonuses from the dialog form
	 */
	static _getBonusesFromForm($form) {
		const bonuses = {};
		if ($form.find("[name=extra-bonus]").length) bonuses.extraBonus = $form.find("[name=extra-bonus]")?.val() ;
		if ($form.find("[name=bono-situacional]").length) bonuses.itemBonus = $form.find("[name=bono-situacional]")?.val() ;
		if ($form.find("[name=bono-correr]").length) bonuses.bonoCorrer = $form.find("[name=bono-correr]")?.prop("checked");
		if ($form.find("[name=bono-saltar]").length) bonuses.bonoSaltar = $form.find("[name=bono-saltar]")?.prop("checked");
		//if ($form.find("[name=weapon-backstab]").length) bonuses.backstab = $form.find("[name=weapon-backstab]")?.prop("checked");
		return bonuses;
	}

    /* -------------------------------------------- */
	/*  Dialogs                                     */
	/* -------------------------------------------- */

	/**
	 * Renders HTML for display as roll dialog
	 * @param {Array<string>} parts		- Dice formula parts
	 * @param {object} data 					- Data for use in the dialog
	 * @param {object} options 				- Configuration options for dialog
	 * @returns {jQuery}							- Rendered HTML object
	 */
	static async _getRollDialogContent(
		parts,
		data,
		options = {}
	) {
		const dialogTemplate = options.dialogTemplate
			? options.dialogTemplate
			//: "systems/shadowdark/templates/dialog/roll-dialog.hbs"; //ACA ESTA USANDO OTRO vs roll-item-dialog.hbs
            : "systems/ARGS/templates/partials/dialogo-roll.hbs";
            
		const dialogData = {
			data,
			title: options.title,
			formula: Array.from(parts).join(" + "),
			rollModes: CONFIG.Dice.rollModes,
			rollMode: options.rollMode,
		};
        
		// If rollMode is already specified, don't override it
		if (!dialogData.rollMode) {
			dialogData.rollMode = game.settings.get("core", "rollMode");
		}

		return renderTemplate(dialogTemplate, dialogData);
	}
    /**
	 * Renders a Roll Dialog and displays the appropriate bonuses
	 * @param {Array<string>} parts - Predetermined roll dice & @bonuses
	 * @param {object} data 				- Data container with dialogTitle
	 * @param {object} options 			- Configuration options for dialog
	 * @returns {Promise(Roll)}			- Returns the promise of evaluated roll(s)
	 */
	static async RollDialog(parts, data, options={}) {
		
		let labelTitle;
		let labelBt =  game.i18n.localize("ARGS.infotexto.tirardado");
		if(data.item?.name){
		let labelTitle = data.item?.name;
		}
		// Render the HTML for the dialog
		let content = await this._getRollDialogContent(parts, data, options);
		
		if(data.item?.type === "armas"){
			labelBt = "ARGS.infotexto.atacar";
			labelTitle =  game.i18n.localize("ARGS.ataque.".concat(data.item.system.atacaCon));
			if (data.esDefensa && data.esDefensa === true){
				labelBt = "ARGS.infotexto.defender";
			labelTitle =  game.i18n.localize("ARGS.arma.defiendeCon")  ;				
			}

		}
		if(data.item?.type === "hechizo"){
			labelBt = "ARGS.hechizos.lanzar";
			labelTitle =  game.i18n.localize("ARGS.magia.escuelas.".concat(data.item.system.escuela)) + " - " + game.i18n.localize("ARGS.hechizos.".concat(data.item.system.dios));
		}
		if(data.item?.type === "monturas"){
			if (data.flagInstinto === 1){
			labelTitle = game.i18n.localize("ARGS.monturas.instinto");
			}
			if (data.flagDestreza === 1){
				labelTitle = game.i18n.localize("ARGS.monturas.destreza");
				}
			if (data.flagAtaque === 1){
				labelBt = "ARGS.infotexto.atacar";
				labelTitle = game.i18n.localize("ARGS.monturas.ataque");
				}
		}
		

		if (!options.title) {
			options.title = labelTitle + " - " + data.item.name;
		}


		const dialogData = {
			title: options.title,
			content,
			classes: ["ARGS-dialogo"],//shadowdark-dialog
			buttons: {				
				normal: {
					
					label: game.i18n.localize(labelBt),
					callback: async html => {
						return this.Roll(parts, data, html, options);
					},
				}
			},
			close: () => null,
			default: "normal",
			render: html => {				
			},
		};

		return Dialog.wait(dialogData, options.dialogOptions);
	}



	
	/* -------------------------------------------- */
	/*  Chat Card Generation for Displaying         */
	/* -------------------------------------------- */

	/**
	 * Parse roll data and optional target value
	 * @param {object} rollResult 		- Response from `_roll()`
	 * @param {object} speaker  			- ChatMessage.getSpeaker who will be sending the message
	 * @param {number|false} target 	- Target value to beat with the roll
	 * @return {object}								- Data for rendering a chatcard
	 */
	static _getChatCardData(rolls, speaker, target=false) {
		
		const chatData = {
			user: game.user.id,
			speaker: speaker,
			flags: {
				isRoll: true,
				rolls: rolls,
				"core.canPopout": true,
				hasTarget: target !== false,
				critical: rolls.main.critical,
			},
		};
		
		if (target) chatData.flags.success = rolls.main.roll.total >= target;
		return chatData;
	}

	/**
	 * Generate Template Data for displaying custom chat cards
	 * @param {object} data 		- Optional data containing `item` and `actor`
	 * @param {object} options 	- Optional options for configuring chat card,
	 * e.g. `flavor`, `title`
	 * @returns {object}				- Data to populate the Chat Card template
	 */
	static async _getChatCardTemplateData(data, options={}) {
		const templateData = {
			data,
			title: (options.title) ? options.title : game.i18n.localize("SHADOWDARK.chatcard.default"),
			flavor: (options.flavor)
				? options.flavor : (options.title)
					? options.title : game.i18n.localize("SHADOWDARK.chatcard.default"),
			isSpell: false,
			isWeapon: false,			
			isRoll: true,
			isNPC: data.actor?.type === "NPC",
			targetDC: options.target ?? false,
		};	
		
		
		if (data.rolls.main) {
			templateData._formula = data.rolls.main.roll._formula;
		}
		if (data.item) {
			if(data.item.type === "hechizo"){
			templateData.isSpell = true;
			}
			if(data.item.type === "armas"){			
			templateData.isWeapon = true;
			}
			const propertyNames = [];			

			templateData.propertyNames = propertyNames;
		}
		return templateData;
	}

	/**
	 * Generate HTML for a chat card for a roll
	 * @param {object} data 		- Optional data containing `item` and `actor`
	 * @param {object} options 	- Optional options for configuring chat card,
	 * e.g. `flavor`, `title`
	 * @returns {jQuery}				- Rendered HTML for chat card
	 */
	static async _getChatCardContent(
		data,
		options = {}
	) {
		const chatCardTemplate = options.chatCardTemplate
			? options.chatCardTemplate
			: "systems/ARGS/templates/partials/chat/roll-tarjeta.hbs";

		const chatCardData = await this._getChatCardTemplateData(data, options);

		return renderTemplate(chatCardTemplate, chatCardData);
	}

	/**
	 * Takes a data objcet containing rolls and renders them. Also optionally
	 * renders 3D Dice using Dice So Nice integration.
	 * @param {object} data 			- Data from rolling
	 * @param {-1|0|1} adv 				- Advantage indicator
	 * @param {object} options 		- Optional configuration for chat card
	 * @returns {Promise<object>}
	 */
	static async _renderRoll(data, options={}) {
		const chatData = await this._getChatCardData(
			data.rolls,
			(options.speaker) ? options.speaker : ChatMessage.getSpeaker(),
			options.target
		);

		// TODO: Write tests for this.
		// Add whether the roll succeeded or not to the roll data


		data.rolls.main.success = (chatData.flags.success)
			? chatData.flags.success
			: null;

		if ( options.rollMode === "blindroll" ) data.rolls.main.blind = true;

		const content = await this._getChatCardContent(data, options);

		chatData.content = content;

		// Modify the flavor of the chat card
		if (options.flavor) {
			chatData.flavor = options.flavor;

		
		}

		// Integration with Dice So Nice
		if (game.dice3d) {
			await this._rollDiceSoNice(data.rolls, chatData, options.chatMessage);
		}
		else {
			chatData.sound = CONFIG.sounds.dice;
		}

		if (options.chatMessage !== false) {
			ChatMessage.applyRollMode(chatData, options.rollMode);
			ChatMessage.create(chatData);
		}

		return data;
	}

	
	static async sleep(seconds) {
	return new Promise(resolve => setTimeout(resolve, seconds * 1000));
  }
	/* -------------------------------------------- */
	/*  Integrations                                */
	/* -------------------------------------------- */

	/**
	 * Renders Dice So Nice in order of D20 -> Damage Rolls and creates
	 * a chat message with the generated content.
	 * @param {object} rolls 					- Object containing evaluated rolls
	 * @param {object} chatData 			- Parsed roll data as generated by _getchatCardData
	 * 																  augmented with content from
	 *                                  _getChatCardTemplateData
	 * @param {boolean} chatMessage 	- Boolean to display chat message or just generate it
	 * @return {object}								- Returns the D20 result
	 */
	static async _rollDiceSoNice(rolls) {
		const rollsToShow = [rolls.main.roll];
		
		if ( rolls.main.roll1 ) {
			rollsToShow.unshift(rolls.main.roll1);
		}
		if ( rolls.secondaryDamage ) {
			rollsToShow.push(rolls.secondaryDamage.roll);
		}

		// TODO Make sure we honor the whisper and/or blind settings of the roll
		//
		// Only await on the final dice roll of the sequence as it looks nicer
		// if all the dice roll before the chat message appears
		const numRolls = rollsToShow.length;
		let currentRoll = 1;
		for (const roll of rollsToShow) {
			if (currentRoll === numRolls) {				
				await game.dice3d.showForRoll(roll, game.user, true);				
			}
			else {
				game.dice3d.showForRoll(roll, game.user, true);
				await this.sleep(2); // Wait for 3 seconds
			}
			currentRoll++;
		}
	}
	
	
}
	